In this section, we have provided experiment analysis. In the experiment, we have focused on (1) correctness of our proposed algorithm and (2) the comparison with existing algorithm SUF-growth ~\cite{suf_growth}. For the extensive experiment, we have chosen the mushroom dataset  and T40I10D100K database. The reason we have chosen these two datasets is, the mushroom  is real life dataset and dense dataset whereas T40I10D100K  is synthetic and sparse dataset generated by a generator from the IBM Almaden Quest. Table \ref{table:dataset} shows the details the properties for dataset . Later we have also taken chess  for comparison with the algorithm. The experimental results have been given in the following subsections.
\subsection{Algorithm Performance Analysis}
    \paragraph{Total Database Size Change Effect}Our experiment shows clearly that our proposed tree construction algorithm \emph{US-tree}, tree mining algorithm \emph{USFP-growth} works nicely with any size of window, batch or transaction size. For the different size of the database (transaction count in a tree), this algorithm works extensively. Figure-\ref{result:g_m_const_tran} shows the total runtime (includes tree construction, mining, and false positive reduction) change with the growth of the size of the mushroom dataset. Figure-\ref{result:g_t10_const_tran} the same characteristic for T40I10D100K dataset. Figure-\ref{result:g_m_const_tran_mem} and figure-\ref{result:g_t10_const_tran_mem} shows the total nodes change in a tree while the size of database grows for databases corresponding to mushroom and T40I10D100K database. The growth of the graphs is very much regular. From these graphs, it is clearly visible that, with the growth of total transaction the time increases and this certainly proves the scalability of our algorithm. 
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        \begin{figure}[h]
        \centering
            \input{result/mushroom/g_m_const_tran}
        \caption{Size of Database vs Runtime for Mushroom Dataset }
        \label{result:g_m_const_tran}
        \end{figure}
        \begin{figure}[h]
        \centering
            \input{result/t10/g_t10_const_tran}
        \caption{Size of Database vs Runtime for T40I10D100K Dataset }
        \label{result:g_t10_const_tran}
        \end{figure}
%        \begin{figure}[h]
%        \centering
%            \input{result/kosarak/g_k_const_tran}
%        \caption{Size of Database vs Runtime for Kosarak Dataset }
%        \label{result:g_k_const_tran}
%        \end{figure}
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%        \begin{figure}[h]
%        \centering
%            \input{result/mushroom/g_m_const_tran_mem}
%        \caption{Size of Database vs Total Nodes in Tree for Mushroom Dataset }
%        \label{result:g_m_const_tran_mem}
%        \end{figure}
%        \begin{figure}[h]
%        \centering
%            \input{result/t10/g_t10_const_tran_mem}
%        \caption{Size of Database vs Total Nodes in Tree for T40I10D100K Dataset }
%        \label{result:g_t10_const_tran_mem}
%        \end{figure}
%        \begin{figure}[h]
%        \centering
%            \input{result/kosarak/g_k_const_tran_mem}
%        \caption{Size of Database vs Total Nodes in Tree for Kosarak Dataset }
%        \label{result:g_k_const_tran_mem}
%        \end{figure}
%        
		\begin{table}[h]
        \centering
        \begin{tabular}{|c|c|}
        \hline 
       Size of Database        &    Memory (in MB)\\    \hline\hline
        
				1000&0.473\\\hline
				2000&0.795\\\hline
				3000&1.135\\\hline
				4000&1.442\\\hline
				5000&1.762\\\hline
		
            \end{tabular}
        \caption{ Total Memory (in MB) in Tree for Mushroom Dataset}
        \label{result:g_m_const_tran_mem}
        \end{table}
		
		\begin{table}[h]
        \centering
        \begin{tabular}{|c|c|}
        \hline 
       Size of Database       &    Memory (in MB)\\    \hline\hline
        
				8000 &23.504\\\hline
				10000&46.736\\\hline
				24000&69.861\\\hline
				32000&92.903\\\hline
				40000&115.888\\\hline
		
            \end{tabular}
        \caption{ Total Memory (in MB) in Tree for T40I10D100K Dataset}
        \label{result:g_t10_const_tran_mem}
        \end{table}
    \paragraph{Window Size Change Effect}For window size change effect we have experimented our algorithm in the different angle. The experiment shows the window size change effect do not hamper performance and it is consistent. Figure-\ref{result:g_m_const_batch} and figure-\ref{result:g_t10_const_batch} shows effect of window size change effect on mushroom and T40I10D100K dataset.
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        \begin{figure}[h]
        \centering
            \input{result/mushroom/g_m_const_batch}
        \caption{Batch Size vs Runtime for Mushroom Dataset }
        \label{result:g_m_const_batch}
        \end{figure}
        \begin{figure}[h]
        \centering
            \input{result/t10/g_t10_const_batch}
        \caption{Batch Size vs Runtime for T40I10D100K Dataset }
        \label{result:g_t10_const_batch}
        \end{figure}
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        
    \paragraph{Batch Size Change Effect}Like batch change effect we also experimented for batch size change effect.For changing batch size in different volume the result we find is consistent. For constant window and variable batches we have simulated our proposed algorithms. Figure-\ref{result:g_m_const_batch} and figure-\ref{result:g_t10_const_batch} shows effect of batch size change effect on mushroom and T40I10D100K dataset.
        \begin{figure}[h]
        \centering
            \input{result/mushroom/g_m_const_win}
        \caption{Window Size vs Runtime for Mushroom Dataset }
        \label{result:g_m_const_win}
        \end{figure}
        \begin{figure}[h]
        \centering
            \input{result/t10/g_t10_const_win}
        \caption{Window Size vs Runtime for T40I10D100K Dataset }
        \label{result:g_t10_const_win}
        \end{figure}
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        
\subsection{Comparison With Existing Approaches}
Here now we have compared our proposed approach with existing system. We have choose SUF-growth ~\cite{suf_growth}  for comparison. This algorithm is perfectly fit for uncertain stream data mining. UF-streaming also designed for mining frequent patterns from uncertain stream but in ~\cite{suf_growth} it has been proved that in all criteria (runtime, memory and correctness) SUF-growth ~\cite{suf_growth} is better than UF-streaming ~\cite{suf_growth}. We have experimented for both runtime performance and memory efficiency. The result has described below:
    \subsubsection{Runtime Comparison}
    Runtime comparison has been experimented and the in the result we found is consistent and we have gained runtime efficiency for both dense and sparse dataset. For mushroom dataset our approach's total tree construction time , total mining time and total time has been compared with SUF-growth ~\cite{suf_growth}'s tree construction time and mining time and total time. Figure-\ref{result:g_m_tree_construction_total}, figure-\ref{result:g_m_mining_total} and figure-\ref{result:g_m_total} shows the result graph. As mushroom is a dense database we gain much more in run time. For dense characteristic the constructed \emph{US-tree} is very much compact and moreover when mining compact tree the mining time surprisingly decreases that affect the total time. Figure-\ref{result:g_t10_tree_construction_total}, figure-\ref{result:g_t10_mining_total} and figure-\ref{result:g_t10_total} shows same comparison for T40I10D100K dataset . The graphs shows that our algorithm works correctly for sparse dataset too. Figure-\ref{result:g_chess_tree_construction_total}, figure-\ref{result:g_chess_mining_total} and figure-\ref{result:g_chess_total} shows tree construction time, mining time and total time for chess dataset. Kosarak is very large and real-life data set. This is web click database. This database is sparse and very much large. \ref{result:g_k_tree_construction_total}, figure-\ref{result:g_k_mining_total} and figure-\ref{result:g_k_total} shows the effect of changing minimum support effect corresponding to tree construction time, mining time and total time. This one is dense dataset and the result is consistent, efficient and also scalable.
            \begin{figure}[h]
            \centering
                \input{result/mushroom/g_m_tree_construction_total}
            \caption{Total Tree Construction Time vs Minimum Support (\%) for Mushroom Dataset }
            \label{result:g_m_tree_construction_total}
            \end{figure}
            
            \begin{figure}[h]
            \centering
                \input{result/mushroom/g_m_mining_total}
            \caption{Total Tree Mining Time vs Minimum Support (\%) for Mushroom Dataset }
            \label{result:g_m_mining_total}
            \end{figure}
            \begin{figure}[h]
            \centering
                \input{result/mushroom/g_m_total}
            \caption{Runtime vs Minimum Support (\%) for Mushroom Dataset }
            \label{result:g_m_total}
            \end{figure}
            \begin{figure}[h]
            \centering
                \input{result/t10/g_t10_tree_construction_total}
            \caption{Total Tree Construction Time vs Minimum Support (\%) for T40I10D100K Dataset }
            \label{result:g_t10_tree_construction_total}
            \end{figure}
            
            \begin{figure}[h]
            \centering
                \input{result/t10/g_t10_mining_total}
            \caption{Total Tree Mining Time vs Minimum Support (\%) for T40I10D100K Dataset }
            \label{result:g_t10_mining_total}
            \end{figure}
            
            \begin{figure}[h]
            \centering
                \input{result/t10/g_t10_total}
            \caption{Runtime vs Minimum Support (\%) for T40I10D100K Dataset }
            \label{result:g_t10_total}
            \end{figure}
    
            \begin{figure}[h]
            \centering
                \input{result/chess/g_chess_tree_construction_total}
            \caption{Total Tree Construction Time vs Minimum Support (\%) for Chess Dataset }
            \label{result:g_chess_tree_construction_total}
            \end{figure}
            
            \begin{figure}[h]
            \centering
                \input{result/chess/g_chess_mining_total}
            \caption{Total Tree Mining Time vs Minimum Support (\%) for Chess Dataset }
            \label{result:g_chess_mining_total}
            \end{figure}
            
            \begin{figure}[h]
            \centering
                \input{result/chess/g_chess_total}
            \caption{Runtime vs Minimum Support (\%) for Chess Dataset }
            \label{result:g_chess_total}
            \end{figure}
            \begin{figure}[h]
            \centering
                \input{result/kosarak/g_k_tree_construction_total}
            \caption{Total Tree Construction Time vs Minimum Support (\%) for Kosarak Dataset }
            \label{result:g_k_tree_construction_total}
            \end{figure}
            
            \begin{figure}[h]
            \centering
                \input{result/kosarak/g_k_mining_total}
            \caption{Total Tree Mining Time vs Minimum Support (\%) for Kosarak Dataset }
            \label{result:g_k_mining_total}
            \end{figure}

            \begin{figure}[h]
            \centering
                \input{result/kosarak/g_k_total}
            \caption{Runtime vs Minimum Support (\%) for Kosarak Dataset }
            \label{result:g_k_total}
            \end{figure}
            
\clearpage
    \subsubsection{Memory Comparison}
        As our proposed \emph{US-tree} have the capability to share nodes more than \emph{SUF-growth}, we get much more gain in memory. The experimental result also indicates that very clearly. Figure-\ref{result:g_m_memory_node} shows the memory comparison on mushroom dataset. Mushroom is the dense database so we get  much more gain in memory. The graph clearly shows that with the increase of total transaction in the tree gives the much more gain. For chess dataset the compactness of tree is also very impressive as this dataset is also compact (figure-\ref{result:g_chess_memory_node}) the Dense dataset have more scope to share nodes more. Figure-\ref{result:g_t10_memory_node} also shows that in T40I10D100K database we also gain the memory optimization. Figure-\ref{result:g_k_memory_node} shows memory comparison between \emph{USFP-growth} vs \emph{SUF-growth} ~\cite{suf_growth}. On this sparse database it has been clearly shown that, lot of memory optimization has been possible with our proposed algorithm. As the database is sparse, we get the memory gain less then dense one.
            \begin{figure}[h]
            \centering
                \input{result/mushroom/g_m_memory_node}
            \caption{Total Memory vs Total Transaction (in thousand) for Mushroom Dataset }
            \label{result:g_m_memory_node}
            \end{figure}
            
            \begin{figure}[h]
            \centering
                \input{result/chess/g_chess_memory_node}
            \caption{Total Memory vs Total Transaction (in thousand) for Chess Dataset }
            \label{result:g_chess_memory_node}
            \end{figure}
            
            \begin{figure}[h]
                \input{result/t10/g_t10_memory_node}
            \caption{Total Memory vs Total Transaction (in thousand) for T40I10D100K Dataset }
            \label{result:g_t10_memory_node}
            \end{figure}
        
            \begin{figure}[h]
            \centering
                \input{result/kosarak/g_k_memory_node}
            \caption{Total Memory vs Total Transaction (in thousand) for Kosarak Dataset }
            \label{result:g_k_memory_node}
            \end{figure}